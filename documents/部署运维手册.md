# 新能源电池进销存系统 - 部署运维手册

## 系统架构概述

### 整体架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用       │    │   后端API服务    │    │   数据库服务     │
│   React App     │───▶│   NestJS App    │───▶│   PostgreSQL    │
│   Port: 3000    │    │   Port: 3001    │    │   Port: 5432    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │              ┌─────────────────┐              │
         │              │   缓存服务       │              │
         └──────────────│   Redis         │──────────────┘
                        │   Port: 6379    │
                        └─────────────────┘
```

### API设计架构
```
统一API设计模式：
├── 基础数据管理模块
│   ├── POST /api/basic-data/products - 产品管理统一接口
│   ├── POST /api/basic-data/suppliers - 供应商管理统一接口
│   ├── POST /api/basic-data/customers - 客户管理统一接口
│   └── POST /api/basic-data/warehouses - 仓库管理统一接口
├── 采购管理模块
│   ├── POST /api/procurement/plans - 采购计划统一接口
│   ├── POST /api/procurement/orders - 采购订单统一接口
│   └── POST /api/procurement/receipts - 收货管理统一接口
├── 库存管理模块
│   ├── POST /api/inventory/stock - 库存管理统一接口
│   ├── POST /api/inventory/transactions - 库存流水统一接口
│   └── POST /api/inventory/alerts - 库存预警统一接口
├── 销售管理模块
│   ├── POST /api/sales/orders - 销售订单统一接口
│   ├── POST /api/sales/deliveries - 出库管理统一接口
│   └── POST /api/sales/customers - 客户关系统一接口
├── 质量控制模块
│   ├── POST /api/quality/inspections - 质量检验统一接口
│   └── POST /api/quality/traceability - 批次追溯统一接口
├── 安全管理模块
│   ├── POST /api/safety/inspections - 安全检查统一接口
│   └── POST /api/safety/environment - 环境监控统一接口
├── 报表统计模块
│   ├── POST /api/reports/templates - 报表模板统一接口
│   └── POST /api/reports/generation - 报表生成统一接口
└── 系统管理模块
    ├── POST /api/system/users - 用户管理统一接口
    ├── POST /api/system/roles - 角色管理统一接口
    └── POST /api/system/permissions - 权限管理统一接口

总计：42个统一接口（原503个REST接口）
```

### 技术栈版本
- **前端**: React 18.2+, TypeScript 5.0+, Vite 5.0+
- **后端**: NestJS 10.0+, Node.js 20.0+, TypeScript 5.0+
- **数据库**: PostgreSQL 14+
- **缓存**: Redis 7.0+
- **容器**: Docker 24.0+, Docker Compose 2.20+

## 环境准备

### 开发环境要求
```bash
# Node.js版本管理
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 20
nvm use 20

# 包管理器
npm install -g pnpm@8

# 开发工具
npm install -g @nestjs/cli
npm install -g typescript
```

### 系统依赖
```bash
# Ubuntu/Debian
sudo apt update
sudo apt install -y curl wget git build-essential

# CentOS/RHEL
sudo yum update
sudo yum install -y curl wget git gcc gcc-c++ make

# Docker安装
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo systemctl enable docker
sudo systemctl start docker

# Docker Compose安装
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```

## 项目构建

### 前端构建
```bash
# 克隆代码
git clone https://github.com/your-org/bolink-inventory-frontend.git
cd bolink-inventory-frontend

# 安装依赖
pnpm install

# 环境变量配置
cp .env.example .env.local
# 编辑 .env.local 文件

# 开发环境启动
pnpm dev

# 生产环境构建
pnpm build

# 预览构建结果
pnpm preview
```

### 后端构建
```bash
# 克隆代码
git clone https://github.com/your-org/bolink-inventory-backend.git
cd bolink-inventory-backend

# 安装依赖
pnpm install

# 环境变量配置
cp .env.example .env
# 编辑 .env 文件

# 数据库迁移
pnpm migration:run

# 种子数据
pnpm seed:run

# 开发环境启动
pnpm start:dev

# 生产环境构建
pnpm build

# 生产环境启动
pnpm start:prod
```

## Docker部署

### 前端Dockerfile
```dockerfile
# frontend/Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 后端Dockerfile
```dockerfile
# backend/Dockerfile
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build

FROM node:20-alpine AS production

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

COPY --from=builder /app/dist ./dist

EXPOSE 3001
CMD ["node", "dist/main"]
```

### Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  # 数据库服务
  postgres:
    image: postgres:15-alpine
    container_name: bolink-postgres
    environment:
      POSTGRES_DB: bolink_inventory
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    networks:
      - bolink-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redis缓存服务
  redis:
    image: redis:7-alpine
    container_name: bolink-redis
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - bolink-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 后端API服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: bolink-backend
    environment:
      NODE_ENV: production
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USERNAME: postgres
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: bolink_inventory
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
      JWT_SECRET: ${JWT_SECRET}
    ports:
      - "3001:3001"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - bolink-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 前端Web服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: bolink-frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - bolink-network
    restart: unless-stopped

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: bolink-nginx
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    ports:
      - "443:443"
      - "80:80"
    depends_on:
      - frontend
      - backend
    networks:
      - bolink-network
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

networks:
  bolink-network:
    driver: bridge
```

### 环境变量配置
```bash
# .env
# 数据库配置
DB_PASSWORD=your_secure_password
DB_NAME=bolink_inventory

# Redis配置
REDIS_PASSWORD=your_redis_password

# JWT配置
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRES_IN=7d

# 应用配置
APP_PORT=3001
APP_ENV=production

# 外部服务配置
MAIL_HOST=smtp.example.com
MAIL_PORT=587
MAIL_USER=noreply@example.com
MAIL_PASS=mail_password
```

## Kubernetes部署

### 命名空间和配置
```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: bolink-inventory

---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: bolink-config
  namespace: bolink-inventory
data:
  DB_HOST: "postgres-service"
  DB_PORT: "5432"
  DB_NAME: "bolink_inventory"
  REDIS_HOST: "redis-service"
  REDIS_PORT: "6379"
  APP_PORT: "3001"

---
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: bolink-secret
  namespace: bolink-inventory
type: Opaque
data:
  DB_PASSWORD: <base64-encoded-password>
  REDIS_PASSWORD: <base64-encoded-password>
  JWT_SECRET: <base64-encoded-secret>
```

### 数据库部署
```yaml
# k8s/postgres.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: bolink-inventory
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              name: bolink-config
              key: DB_NAME
        - name: POSTGRES_USER
          value: "postgres"
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: bolink-secret
              key: DB_PASSWORD
        volumeMounts:
        - name: postgres-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
  volumeClaimTemplates:
  - metadata:
      name: postgres-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi

---
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: bolink-inventory
spec:
  selector:
    app: postgres
  ports:
  - port: 5432
    targetPort: 5432
  clusterIP: None
```

### 应用部署
```yaml
# k8s/backend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: bolink-inventory
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: bolink/inventory-backend:latest
        ports:
        - containerPort: 3001
        envFrom:
        - configMapRef:
            name: bolink-config
        - secretRef:
            name: bolink-secret
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "250m"

---
apiVersion: v1
kind: Service
metadata:
  name: backend-service
  namespace: bolink-inventory
spec:
  selector:
    app: backend
  ports:
  - port: 3001
    targetPort: 3001
  type: ClusterIP
```

### Ingress配置
```yaml
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: bolink-ingress
  namespace: bolink-inventory
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
spec:
  tls:
  - hosts:
    - inventory.yourdomain.com
    secretName: bolink-tls
  rules:
  - host: inventory.yourdomain.com
    http:
      paths:
      - path: /api
        pathType: Prefix
        backend:
          service:
            name: backend-service
            port:
              number: 3001
      - path: /
        pathType: Prefix
        backend:
          service:
            name: frontend-service
            port:
              number: 80
```

## 监控和日志

### Prometheus监控配置
```yaml
# monitoring/prometheus.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
    - job_name: 'bolink-backend'
      static_configs:
      - targets: ['backend-service:3001']
      metrics_path: /metrics
    - job_name: 'postgres'
      static_configs:
      - targets: ['postgres-exporter:9187']
    - job_name: 'redis'
      static_configs:
      - targets: ['redis-exporter:9121']
```

### Grafana仪表板
```json
{
  "dashboard": {
    "title": "Bolink Inventory System",
    "panels": [
      {
        "title": "API请求率",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "title": "数据库连接数",
        "type": "stat",
        "targets": [
          {
            "expr": "pg_stat_database_numbackends",
            "legendFormat": "Active Connections"
          }
        ]
      },
      {
        "title": "内存使用率",
        "type": "graph",
        "targets": [
          {
            "expr": "process_resident_memory_bytes",
            "legendFormat": "{{instance}}"
          }
        ]
      }
    ]
  }
}
```

### 日志收集配置
```yaml
# logging/fluentd.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentd-config
data:
  fluent.conf: |
    <source>
      @type tail
      path /var/log/containers/backend-*.log
      pos_file /var/log/fluentd-containers.log.pos
      tag kubernetes.backend
      format json
    </source>
    
    <filter kubernetes.backend>
      @type record_transformer
      <record>
        service backend
        environment production
      </record>
    </filter>
    
    <match kubernetes.**>
      @type elasticsearch
      host elasticsearch-service
      port 9200
      index_name bolink-logs
    </match>
```

## 备份和恢复

### 数据库备份脚本
```bash
#!/bin/bash
# backup.sh

set -e

DB_HOST=${DB_HOST:-localhost}
DB_PORT=${DB_PORT:-5432}
DB_NAME=${DB_NAME:-bolink_inventory}
DB_USER=${DB_USER:-postgres}
BACKUP_DIR=${BACKUP_DIR:-/backup}
RETENTION_DAYS=${RETENTION_DAYS:-7}

# 创建备份目录
mkdir -p $BACKUP_DIR

# 生成备份文件名
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/bolink_backup_$TIMESTAMP.sql"

echo "开始备份数据库..."
pg_dump -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME \
  --format=custom --compress=9 --verbose \
  --file=$BACKUP_FILE

echo "备份完成: $BACKUP_FILE"

# 清理过期备份
find $BACKUP_DIR -name "bolink_backup_*.sql" -mtime +$RETENTION_DAYS -delete

echo "过期备份已清理"
```

### 自动备份Cron配置
```bash
# 添加到crontab
# 每天凌晨2点执行备份
0 2 * * * /path/to/backup.sh >> /var/log/backup.log 2>&1

# 每周日凌晨1点执行全量备份
0 1 * * 0 /path/to/full-backup.sh >> /var/log/backup.log 2>&1
```

### 数据恢复脚本
```bash
#!/bin/bash
# restore.sh

set -e

DB_HOST=${DB_HOST:-localhost}
DB_PORT=${DB_PORT:-5432}
DB_NAME=${DB_NAME:-bolink_inventory}
DB_USER=${DB_USER:-postgres}
BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
  echo "用法: $0 <backup_file>"
  exit 1
fi

if [ ! -f "$BACKUP_FILE" ]; then
  echo "备份文件不存在: $BACKUP_FILE"
  exit 1
fi

echo "开始恢复数据库..."
echo "警告: 这将覆盖现有数据库 $DB_NAME"
read -p "确认继续? (y/N): " confirm

if [ "$confirm" != "y" ]; then
  echo "操作已取消"
  exit 0
fi

# 删除现有数据库
dropdb -h $DB_HOST -p $DB_PORT -U $DB_USER $DB_NAME

# 创建新数据库
createdb -h $DB_HOST -p $DB_PORT -U $DB_USER $DB_NAME

# 恢复数据
pg_restore -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME \
  --verbose --clean --if-exists $BACKUP_FILE

echo "数据库恢复完成"
```

## 安全配置

### SSL/TLS配置
```nginx
# nginx/ssl.conf
server {
    listen 443 ssl http2;
    server_name inventory.yourdomain.com;

    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    
    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;
    
    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    
    location / {
        proxy_pass http://frontend-service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location /api {
        proxy_pass http://backend-service;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Rate limiting
        limit_req zone=api burst=20 nodelay;
    }
}
```

### 防火墙配置
```bash
# UFW防火墙配置
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp
sudo ufw enable

# 仅允许内网访问数据库
sudo ufw allow from 10.0.0.0/8 to any port 5432
sudo ufw allow from 172.16.0.0/12 to any port 5432
sudo ufw allow from 192.168.0.0/16 to any port 5432
```

## 故障排查

### 常见问题和解决方案

#### 1. 数据库连接失败
```bash
# 检查数据库状态
docker exec -it bolink-postgres pg_isready -U postgres

# 查看数据库日志
docker logs bolink-postgres

# 检查网络连接
docker exec -it bolink-backend ping postgres
```

#### 2. 内存使用过高
```bash
# 查看容器资源使用
docker stats

# 查看Node.js内存使用
docker exec -it bolink-backend node -e "console.log(process.memoryUsage())"

# 调整容器内存限制
docker update --memory=1g bolink-backend
```

#### 3. API响应慢
```bash
# 查看慢查询
docker exec -it bolink-postgres psql -U postgres -d bolink_inventory -c "
SELECT query, mean_time, calls 
FROM pg_stat_statements 
ORDER BY mean_time DESC 
LIMIT 10;"

# 分析应用性能
docker exec -it bolink-backend npm run profile

# 监控统一API接口性能
docker exec -it bolink-backend npm run monitor:api

# 检查Action字典使用情况
docker exec -it bolink-backend npm run analyze:actions
```

### API监控和优化

#### 统一API性能监控
```bash
# 监控API响应时间
curl -X POST http://localhost:3001/api/basic-data/products \
  -H "Content-Type: application/json" \
  -d '{"action": "list", "params": {"page": 1, "pageSize": 20}}' \
  -w "响应时间: %{time_total}s\n"

# 批量测试API性能
for action in create list detail update delete; do
  echo "测试 action: $action"
  curl -X POST http://localhost:3001/api/basic-data/products \
    -H "Content-Type: application/json" \
    -d "{\"action\": \"$action\"}" \
    -w "响应时间: %{time_total}s\n"
done
```

#### Action字典使用分析
```bash
# 分析Action使用频率
docker exec -it bolink-postgres psql -U postgres -d bolink_inventory -c "
SELECT 
  action_type,
  COUNT(*) as usage_count,
  AVG(response_time) as avg_response_time
FROM api_logs 
WHERE created_at >= NOW() - INTERVAL '24 hours'
GROUP BY action_type
ORDER BY usage_count DESC;"
```

### 健康检查脚本
```bash
#!/bin/bash
# health-check.sh

echo "=== Bolink Inventory System Health Check ==="

# 检查服务状态
echo "检查服务状态..."
docker-compose ps

# 检查数据库连接
echo "检查数据库连接..."
docker exec bolink-postgres pg_isready -U postgres

# 检查Redis连接
echo "检查Redis连接..."
docker exec bolink-redis redis-cli ping

# 检查API健康状态
echo "检查API健康状态..."
curl -f http://localhost:3001/health || echo "API健康检查失败"

# 检查前端可访问性
echo "检查前端可访问性..."
curl -f http://localhost:80 || echo "前端访问失败"

# 检查磁盘空间
echo "检查磁盘空间..."
df -h

# 检查内存使用
echo "检查内存使用..."
free -h

echo "=== 健康检查完成 ==="
```

## 运维最佳实践

### 日常维护任务
1. **每日检查**
   - 查看系统资源使用情况
   - 检查错误日志
   - 验证备份完成状态

2. **每周检查**
   - 更新系统安全补丁
   - 清理过期日志文件
   - 检查SSL证书有效期

3. **每月检查**
   - 分析性能趋势
   - 优化数据库索引
   - 审查安全策略

### 性能优化建议
1. **数据库优化**
   - 定期执行VACUUM和ANALYZE
   - 监控慢查询并优化
   - 合理设置连接池大小

2. **应用优化**
   - 启用应用缓存
   - 优化API响应时间
   - 实施CDN加速静态资源

3. **系统优化**
   - 调整内核参数
   - 优化文件系统
   - 配置合适的负载均衡
