# 新能源电池进销存系统 - 数据库视图函数说明文档

## 1. 文档概述

### 1.1 文档目的
本文档详细说明新能源电池进销存系统中所有数据库视图、函数、触发器的功能、使用方法和维护要点。

### 1.2 适用范围
- 数据库管理员
- 后端开发工程师
- 系统运维人员
- 业务分析师

### 1.3 与统一API设计的关系
- **数据支撑**: 数据库视图和函数为统一API提供高效的数据查询和处理能力
- **业务逻辑**: 复杂业务逻辑通过数据库函数实现，简化API层代码
- **性能优化**: 物化视图和索引优化支持统一API的高性能查询需求
- **统计分析**: 统计视图支持统一API中的statistics和report等action操作
- **数据一致性**: 触发器确保统一API操作的数据一致性和完整性

### 1.4 版本信息
- **文档版本**: 1.0.1
- **对应数据库版本**: PostgreSQL 14+
- **最后更新**: 2025-08-24

## 2. 物化视图 (Materialized Views)

### 2.1 库存汇总物化视图

#### 2.1.1 视图定义
```sql
CREATE MATERIALIZED VIEW mv_inventory_summary AS
SELECT 
    p.id as product_id,
    p.product_code,
    p.product_name,
    p.battery_type,
    w.id as warehouse_id,
    w.warehouse_code,
    w.warehouse_name,
    SUM(i.quantity) as total_quantity,
    SUM(i.available_quantity) as available_quantity,
    SUM(i.reserved_quantity) as reserved_quantity,
    SUM(i.damaged_quantity) as damaged_quantity,
    AVG(i.unit_cost) as avg_unit_cost,
    SUM(i.quantity * COALESCE(i.unit_cost, 0)) as total_value,
    COUNT(DISTINCT i.batch_number) as batch_count,
    MIN(i.expiry_date) as earliest_expiry_date,
    MAX(i.last_updated) as last_updated
FROM inventory i
JOIN products p ON i.product_id = p.id
JOIN warehouses w ON i.warehouse_id = w.id
WHERE p.status = 'active' AND w.status = 'active'
GROUP BY p.id, p.product_code, p.product_name, p.battery_type, 
         w.id, w.warehouse_code, w.warehouse_name;
```

#### 2.1.2 功能说明
- **用途**: 提供库存汇总统计信息，支持快速查询
- **更新频率**: 需要手动刷新，建议每日凌晨刷新
- **查询场景**: 库存报表、库存分析、库存预警
- **API支持**: 支持统一API中的 `inventory/stock` 接口的 `statistics` action

#### 2.1.3 使用方法
```sql
-- 查询所有产品的库存汇总
SELECT * FROM mv_inventory_summary;

-- 查询特定产品的库存汇总
SELECT * FROM mv_inventory_summary WHERE product_id = 1;

-- 查询库存价值超过100万的仓库
SELECT warehouse_name, SUM(total_value) as total_warehouse_value
FROM mv_inventory_summary 
GROUP BY warehouse_id, warehouse_name
HAVING SUM(total_value) > 1000000;

-- 刷新物化视图
REFRESH MATERIALIZED VIEW mv_inventory_summary;
```

#### 2.1.4 相关索引
```sql
CREATE INDEX idx_mv_inventory_summary_product ON mv_inventory_summary(product_id);
CREATE INDEX idx_mv_inventory_summary_warehouse ON mv_inventory_summary(warehouse_id);
CREATE INDEX idx_mv_inventory_summary_product_warehouse ON mv_inventory_summary(product_id, warehouse_id);
CREATE INDEX idx_mv_inventory_summary_available_qty ON mv_inventory_summary(available_quantity);
```

## 3. 业务视图 (Business Views)

### 3.1 库存预警视图

#### 3.1.1 视图定义
```sql
CREATE VIEW view_inventory_alerts AS
SELECT 
    p.id as product_id,
    p.product_code,
    p.product_name,
    w.id as warehouse_id,
    w.warehouse_code,
    w.warehouse_name,
    SUM(i.available_quantity) as current_stock,
    a.min_quantity,
    a.reorder_point,
    CASE 
        WHEN SUM(i.available_quantity) <= a.min_quantity THEN 'critical'
        WHEN SUM(i.available_quantity) <= a.reorder_point THEN 'warning'
        ELSE 'normal'
    END as alert_level,
    GREATEST(0, a.reorder_point - SUM(i.available_quantity)) as shortage_quantity
FROM inventory i
JOIN products p ON i.product_id = p.id
JOIN warehouses w ON i.warehouse_id = w.id
JOIN inventory_alerts a ON a.product_id = p.id AND (a.warehouse_id = w.id OR a.warehouse_id IS NULL)
WHERE p.status = 'active' AND w.status = 'active' AND a.alert_enabled = true
GROUP BY p.id, p.product_code, p.product_name, w.id, w.warehouse_code, w.warehouse_name,
         a.min_quantity, a.reorder_point
HAVING SUM(i.available_quantity) <= COALESCE(a.reorder_point, a.min_quantity);
```

#### 3.1.2 功能说明
- **用途**: 实时监控库存预警状态
- **预警级别**: critical(紧急)、warning(警告)、normal(正常)
- **计算逻辑**: 基于当前库存与预警阈值比较

#### 3.1.3 使用方法
```sql
-- 查询所有预警信息
SELECT * FROM view_inventory_alerts;

-- 查询紧急预警
SELECT * FROM view_inventory_alerts WHERE alert_level = 'critical';

-- 查询特定仓库的预警
SELECT * FROM view_inventory_alerts WHERE warehouse_id = 1;

-- 统计各预警级别数量
SELECT alert_level, COUNT(*) as alert_count
FROM view_inventory_alerts
GROUP BY alert_level;
```

### 3.2 即将过期库存视图

#### 3.2.1 视图定义
```sql
CREATE VIEW view_expiring_inventory AS
SELECT 
    i.id,
    p.product_code,
    p.product_name,
    w.warehouse_code,
    w.warehouse_name,
    i.batch_number,
    i.location_code,
    i.available_quantity,
    i.production_date,
    i.expiry_date,
    (i.expiry_date - CURRENT_DATE) as days_to_expire,
    CASE 
        WHEN i.expiry_date <= CURRENT_DATE THEN 'expired'
        WHEN i.expiry_date <= CURRENT_DATE + INTERVAL '7 days' THEN 'critical'
        WHEN i.expiry_date <= CURRENT_DATE + INTERVAL '30 days' THEN 'warning'
        ELSE 'normal'
    END as expiry_status
FROM inventory i
JOIN products p ON i.product_id = p.id
JOIN warehouses w ON i.warehouse_id = w.id
WHERE i.expiry_date IS NOT NULL 
  AND i.available_quantity > 0
  AND i.expiry_date <= CURRENT_DATE + INTERVAL '90 days'
ORDER BY i.expiry_date;
```

#### 3.2.2 功能说明
- **用途**: 监控即将过期的库存
- **监控范围**: 90天内到期的库存
- **状态分类**: expired(已过期)、critical(7天内)、warning(30天内)、normal(正常)

#### 3.2.3 使用方法
```sql
-- 查询所有即将过期的库存
SELECT * FROM view_expiring_inventory;

-- 查询已过期的库存
SELECT * FROM view_expiring_inventory WHERE expiry_status = 'expired';

-- 查询7天内即将过期的库存
SELECT * FROM view_expiring_inventory WHERE expiry_status = 'critical';

-- 按仓库统计过期库存
SELECT warehouse_name, expiry_status, COUNT(*) as count
FROM view_expiring_inventory
GROUP BY warehouse_name, expiry_status
ORDER BY warehouse_name, expiry_status;
```

### 3.3 订单完成度视图

#### 3.3.1 视图定义
```sql
CREATE VIEW view_order_completion AS
SELECT 
    'purchase' as order_type,
    po.id as order_id,
    po.order_code,
    po.supplier_id as partner_id,
    s.supplier_name as partner_name,
    po.order_date,
    po.expected_date,
    po.status,
    SUM(poi.quantity) as total_quantity,
    SUM(poi.received_quantity) as completed_quantity,
    CASE 
        WHEN SUM(poi.quantity) = 0 THEN 0
        ELSE (SUM(poi.received_quantity) / SUM(poi.quantity) * 100)::DECIMAL(5,2)
    END as completion_rate,
    po.final_amount as total_amount
FROM purchase_orders po
JOIN purchase_order_items poi ON po.id = poi.order_id
JOIN suppliers s ON po.supplier_id = s.id
GROUP BY po.id, po.order_code, po.supplier_id, s.supplier_name, po.order_date, po.expected_date, po.status, po.final_amount

UNION ALL

SELECT 
    'sales' as order_type,
    so.id as order_id,
    so.order_code,
    so.customer_id as partner_id,
    c.customer_name as partner_name,
    so.order_date,
    so.delivery_date as expected_date,
    so.status,
    SUM(soi.quantity) as total_quantity,
    SUM(soi.shipped_quantity) as completed_quantity,
    CASE 
        WHEN SUM(soi.quantity) = 0 THEN 0
        ELSE (SUM(soi.shipped_quantity) / SUM(soi.quantity) * 100)::DECIMAL(5,2)
    END as completion_rate,
    so.final_amount as total_amount
FROM sales_orders so
JOIN sales_order_items soi ON so.id = soi.order_id
JOIN customers c ON so.customer_id = c.id
GROUP BY so.id, so.order_code, so.customer_id, c.customer_name, so.order_date, so.delivery_date, so.status, so.final_amount;
```

#### 3.3.2 功能说明
- **用途**: 统一查看采购订单和销售订单的完成情况
- **完成率计算**: (已完成数量 / 总数量) * 100%
- **订单类型**: purchase(采购订单)、sales(销售订单)

#### 3.3.3 使用方法
```sql
-- 查询所有订单完成情况
SELECT * FROM view_order_completion;

-- 查询采购订单完成情况
SELECT * FROM view_order_completion WHERE order_type = 'purchase';

-- 查询完成率低于80%的订单
SELECT * FROM view_order_completion WHERE completion_rate < 80;

-- 按供应商统计平均完成率
SELECT partner_name, AVG(completion_rate) as avg_completion_rate
FROM view_order_completion 
WHERE order_type = 'purchase'
GROUP BY partner_name
ORDER BY avg_completion_rate DESC;
```

### 3.4 供应商业绩统计视图

#### 3.4.1 视图定义
```sql
CREATE VIEW view_supplier_performance AS
SELECT 
    s.id as supplier_id,
    s.supplier_code,
    s.supplier_name,
    s.cooperation_level,
    COUNT(DISTINCT po.id) as total_orders,
    COUNT(DISTINCT CASE WHEN po.status = 'completed' THEN po.id END) as completed_orders,
    SUM(po.final_amount) as total_amount,
    SUM(CASE WHEN po.status = 'completed' THEN po.final_amount ELSE 0 END) as completed_amount,
    AVG(CASE 
        WHEN po.expected_date IS NOT NULL AND po.approved_at IS NOT NULL 
        THEN po.expected_date - po.approved_at::date 
    END) as avg_delivery_days,
    COUNT(DISTINCT qi.id) as quality_inspections,
    COUNT(DISTINCT CASE WHEN qi.conclusion = 'qualified' THEN qi.id END) as qualified_inspections,
    CASE 
        WHEN COUNT(DISTINCT qi.id) = 0 THEN NULL
        ELSE (COUNT(DISTINCT CASE WHEN qi.conclusion = 'qualified' THEN qi.id END)::DECIMAL / COUNT(DISTINCT qi.id) * 100)::DECIMAL(5,2)
    END as qualification_rate
FROM suppliers s
LEFT JOIN purchase_orders po ON s.id = po.supplier_id
LEFT JOIN quality_inspections qi ON s.id = qi.supplier_id
WHERE s.status = 'active'
GROUP BY s.id, s.supplier_code, s.supplier_name, s.cooperation_level;
```

#### 3.4.2 功能说明
- **用途**: 综合评估供应商的交付、质量、成本表现
- **评估维度**: 订单完成率、交付及时性、质量合格率
- **数据来源**: 采购订单、质量检验记录

#### 3.4.3 使用方法
```sql
-- 查询所有供应商业绩
SELECT * FROM view_supplier_performance;

-- 查询战略供应商业绩
SELECT * FROM view_supplier_performance WHERE cooperation_level = 'strategic';

-- 查询质量合格率最高的供应商
SELECT * FROM view_supplier_performance 
WHERE qualification_rate IS NOT NULL
ORDER BY qualification_rate DESC;

-- 查询平均交付天数最短的供应商
SELECT * FROM view_supplier_performance 
WHERE avg_delivery_days IS NOT NULL
ORDER BY avg_delivery_days ASC;
```

### 3.5 客户销售统计视图

#### 3.5.1 视图定义
```sql
CREATE VIEW view_customer_sales AS
SELECT 
    c.id as customer_id,
    c.customer_code,
    c.customer_name,
    c.customer_type,
    c.industry,
    COUNT(DISTINCT so.id) as total_orders,
    COUNT(DISTINCT CASE WHEN so.status = 'completed' THEN so.id END) as completed_orders,
    SUM(so.final_amount) as total_amount,
    SUM(CASE WHEN so.status = 'completed' THEN so.final_amount ELSE 0 END) as completed_amount,
    AVG(so.final_amount) as avg_order_amount,
    MAX(so.order_date) as last_order_date,
    COUNT(DISTINCT EXTRACT(YEAR FROM so.order_date)||'-'||EXTRACT(MONTH FROM so.order_date)) as active_months
FROM customers c
LEFT JOIN sales_orders so ON c.id = so.customer_id
WHERE c.status = 'active'
GROUP BY c.id, c.customer_code, c.customer_name, c.customer_type, c.industry;
```

#### 3.5.2 功能说明
- **用途**: 分析客户销售表现和客户价值
- **分析维度**: 订单数量、销售金额、平均订单金额、活跃度
- **应用场景**: 客户分级、销售策略制定

#### 3.5.3 使用方法
```sql
-- 查询所有客户销售统计
SELECT * FROM view_customer_sales;

-- 查询销售额最高的客户
SELECT * FROM view_customer_sales ORDER BY total_amount DESC LIMIT 10;

-- 查询新能源汽车行业的客户
SELECT * FROM view_customer_sales WHERE industry = '新能源汽车';

-- 查询最近3个月有订单的客户
SELECT * FROM view_customer_sales 
WHERE last_order_date >= CURRENT_DATE - INTERVAL '3 months';
```

### 3.6 产品销售统计视图

#### 3.6.1 视图定义
```sql
CREATE VIEW view_product_sales AS
SELECT 
    p.id as product_id,
    p.product_code,
    p.product_name,
    p.battery_type,
    p.series,
    COUNT(DISTINCT soi.order_id) as order_count,
    SUM(soi.quantity) as total_sold_quantity,
    SUM(soi.shipped_quantity) as total_shipped_quantity,
    SUM(soi.total_price) as total_sales_amount,
    AVG(soi.unit_price) as avg_unit_price,
    MAX(so.order_date) as last_sale_date,
    COUNT(DISTINCT so.customer_id) as customer_count
FROM products p
LEFT JOIN sales_order_items soi ON p.id = soi.product_id
LEFT JOIN sales_orders so ON soi.order_id = so.id AND so.status IN ('approved', 'completed')
WHERE p.status = 'active'
GROUP BY p.id, p.product_code, p.product_name, p.battery_type, p.series;
```

#### 3.6.2 功能说明
- **用途**: 分析产品销售表现和市场接受度
- **分析维度**: 销售数量、销售金额、客户数量、销售频率
- **应用场景**: 产品生命周期管理、销售策略优化

#### 3.6.3 使用方法
```sql
-- 查询所有产品销售统计
SELECT * FROM view_product_sales;

-- 查询销售额最高的产品
SELECT * FROM view_product_sales ORDER BY total_sales_amount DESC;

-- 查询磷酸铁锂系列产品
SELECT * FROM view_product_sales WHERE battery_type = '磷酸铁锂';

-- 查询最近30天有销售的产品
SELECT * FROM view_product_sales 
WHERE last_sale_date >= CURRENT_DATE - INTERVAL '30 days';
```

## 4. 实用函数 (Utility Functions)

### 4.1 库存管理函数

#### 4.1.1 获取产品可用库存函数
```sql
CREATE OR REPLACE FUNCTION get_available_inventory(p_product_id INTEGER, p_warehouse_id INTEGER DEFAULT NULL)
RETURNS TABLE (
    warehouse_id INTEGER,
    warehouse_name VARCHAR(200),
    total_quantity DECIMAL(12,3),
    available_quantity DECIMAL(12,3),
    reserved_quantity DECIMAL(12,3)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        i.warehouse_id,
        w.warehouse_name,
        SUM(i.quantity) as total_quantity,
        SUM(i.available_quantity) as available_quantity,
        SUM(i.reserved_quantity) as reserved_quantity
    FROM inventory i
    JOIN warehouses w ON i.warehouse_id = w.id
    WHERE i.product_id = p_product_id
      AND (p_warehouse_id IS NULL OR i.warehouse_id = p_warehouse_id)
      AND i.status = 'available'
    GROUP BY i.warehouse_id, w.warehouse_name
    ORDER BY i.warehouse_id;
END;
$$ LANGUAGE plpgsql;
```

**使用方法**:
```sql
-- 查询产品在所有仓库的库存
SELECT * FROM get_available_inventory(1);

-- 查询产品在特定仓库的库存
SELECT * FROM get_available_inventory(1, 1);
```

#### 4.1.2 库存预留自动过期函数
```sql
CREATE OR REPLACE FUNCTION auto_expire_reservations()
RETURNS INTEGER AS $$
DECLARE
    expired_count INTEGER := 0;
BEGIN
    UPDATE inventory_reservations 
    SET status = 'expired', 
        released_at = CURRENT_TIMESTAMP,
        released_by = 0
    WHERE status = 'active' 
      AND expiry_date < CURRENT_DATE;
    
    GET DIAGNOSTICS expired_count = ROW_COUNT;
    RETURN expired_count;
END;
$$ LANGUAGE plpgsql;
```

**使用方法**:
```sql
-- 执行自动过期处理
SELECT auto_expire_reservations();

-- 查看过期结果
SELECT COUNT(*) FROM inventory_reservations WHERE status = 'expired';
```

#### 4.1.3 计算库存周转率函数
```sql
CREATE OR REPLACE FUNCTION calculate_inventory_turnover(p_product_id INTEGER, p_days INTEGER DEFAULT 365)
RETURNS DECIMAL(10,4) AS $$
DECLARE
    avg_inventory DECIMAL(12,3);
    total_outbound DECIMAL(12,3);
    turnover_rate DECIMAL(10,4);
BEGIN
    -- 计算平均库存
    SELECT AVG(quantity) INTO avg_inventory
    FROM inventory 
    WHERE product_id = p_product_id 
      AND status = 'available';
    
    -- 计算指定期间的出库总量
    SELECT COALESCE(SUM(ABS(quantity)), 0) INTO total_outbound
    FROM inventory_transactions 
    WHERE product_id = p_product_id 
      AND transaction_type IN ('outbound', 'transfer_out')
      AND created_at >= CURRENT_DATE - p_days;
    
    -- 计算周转率
    IF avg_inventory > 0 THEN
        turnover_rate := total_outbound / avg_inventory;
    ELSE
        turnover_rate := 0;
    END IF;
    
    RETURN turnover_rate;
END;
$$ LANGUAGE plpgsql;
```

**使用方法**:
```sql
-- 计算产品年度周转率
SELECT calculate_inventory_turnover(1, 365);

-- 计算产品季度周转率
SELECT calculate_inventory_turnover(1, 90);

-- 计算产品月度周转率
SELECT calculate_inventory_turnover(1, 30);
```

### 4.2 数据验证函数

#### 4.2.1 验证产品编码格式函数
```sql
CREATE OR REPLACE FUNCTION validate_product_code(code VARCHAR(50))
RETURNS BOOLEAN AS $$
BEGIN
    -- 检查产品编码格式：BT-YYYYMMDD-XXX
    RETURN code ~ '^BT-[0-9]{8}-[0-9]{3}$';
END;
$$ LANGUAGE plpgsql;
```

**使用方法**:
```sql
-- 验证产品编码格式
SELECT validate_product_code('BT-20241201-001');  -- 返回 true
SELECT validate_product_code('INVALID-CODE');     -- 返回 false

-- 在插入数据时验证
INSERT INTO products (product_code, product_name) 
VALUES ('BT-20241201-001', '测试产品')
WHERE validate_product_code('BT-20241201-001');
```

#### 4.2.2 验证供应商编码格式函数
```sql
CREATE OR REPLACE FUNCTION validate_supplier_code(code VARCHAR(50))
RETURNS BOOLEAN AS $$
BEGIN
    -- 检查供应商编码格式：SUP-YYYYMMDD-XXX
    RETURN code ~ '^SUP-[0-9]{8}-[0-9]{3}$';
END;
$$ LANGUAGE plpgsql;
```

#### 4.2.3 验证客户编码格式函数
```sql
CREATE OR REPLACE FUNCTION validate_customer_code(code VARCHAR(50))
RETURNS BOOLEAN AS $$
BEGIN
    -- 检查客户编码格式：CUS-YYYYMMDD-XXX
    RETURN code ~ '^CUS-[0-9]{8}-[0-9]{3}$';
END;
$$ LANGUAGE plpgsql;
```

### 4.3 分区管理函数

#### 4.3.1 创建季度分区函数
```sql
CREATE OR REPLACE FUNCTION create_quarterly_partition(target_year INTEGER, target_quarter INTEGER)
RETURNS TEXT AS $$
DECLARE
    table_name TEXT;
    start_date DATE;
    end_date DATE;
    sql_stmt TEXT;
BEGIN
    -- 计算表名
    table_name := 'operation_logs_y' || target_year || 'q' || target_quarter;
    
    -- 计算季度开始和结束日期
    CASE target_quarter
        WHEN 1 THEN
            start_date := (target_year || '-01-01')::DATE;
            end_date := (target_year || '-04-01')::DATE;
        WHEN 2 THEN
            start_date := (target_year || '-04-01')::DATE;
            end_date := (target_year || '-07-01')::DATE;
        WHEN 3 THEN
            start_date := (target_year || '-07-01')::DATE;
            end_date := (target_year || '-10-01')::DATE;
        WHEN 4 THEN
            start_date := (target_year || '-10-01')::DATE;
            end_date := ((target_year + 1) || '-01-01')::DATE;
        ELSE
            RAISE EXCEPTION '季度参数无效: %, 必须是1-4', target_quarter;
    END CASE;
    
    -- 检查分区是否已存在
    IF EXISTS (SELECT 1 FROM pg_tables WHERE tablename = table_name) THEN
        RETURN '分区表 ' || table_name || ' 已存在';
    END IF;
    
    -- 创建分区表
    sql_stmt := 'CREATE TABLE ' || table_name || ' PARTITION OF operation_logs FOR VALUES FROM (''' 
                || start_date || ''') TO (''' || end_date || ''')';
    EXECUTE sql_stmt;
    
    -- 创建索引
    sql_stmt := 'CREATE INDEX idx_' || table_name || '_user_time ON ' || table_name || '(user_id, operation_time)';
    EXECUTE sql_stmt;
    
    sql_stmt := 'CREATE INDEX idx_' || table_name || '_resource ON ' || table_name || '(resource, action)';
    EXECUTE sql_stmt;
    
    sql_stmt := 'CREATE INDEX idx_' || table_name || '_module ON ' || table_name || '(module)';
    EXECUTE sql_stmt;
    
    sql_stmt := 'CREATE INDEX idx_' || table_name || '_operation_type ON ' || table_name || '(operation_type)';
    EXECUTE sql_stmt;
    
    RETURN '成功创建分区表: ' || table_name || ' (时间范围: ' || start_date || ' 到 ' || end_date || ')';
END;
$$ LANGUAGE plpgsql;
```

**使用方法**:
```sql
-- 创建2025年Q1分区
SELECT create_quarterly_partition(2025, 1);

-- 创建2025年Q2分区
SELECT create_quarterly_partition(2025, 2);
```

#### 4.3.2 自动创建未来分区函数
```sql
CREATE OR REPLACE FUNCTION auto_create_log_partitions()
RETURNS TEXT AS $$
DECLARE
    current_year INTEGER;
    current_quarter INTEGER;
    next_year INTEGER;
    next_quarter INTEGER;
    result TEXT := '';
    temp_result TEXT;
BEGIN
    -- 获取当前年份和季度
    current_year := EXTRACT(YEAR FROM CURRENT_DATE);
    current_quarter := EXTRACT(QUARTER FROM CURRENT_DATE);
    
    -- 计算下一个季度
    IF current_quarter = 4 THEN
        next_year := current_year + 1;
        next_quarter := 1;
    ELSE
        next_year := current_year;
        next_quarter := current_quarter + 1;
    END IF;
    
    -- 创建下一个季度的分区
    SELECT create_quarterly_partition(next_year, next_quarter) INTO temp_result;
    result := result || temp_result || E'\n';
    
    -- 创建再下一个季度的分区（提前准备）
    IF next_quarter = 4 THEN
        next_year := next_year + 1;
        next_quarter := 1;
    ELSE
        next_quarter := next_quarter + 1;
    END IF;
    
    SELECT create_quarterly_partition(next_year, next_quarter) INTO temp_result;
    result := result || temp_result || E'\n';
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

**使用方法**:
```sql
-- 自动创建未来2个季度的分区
SELECT auto_create_log_partitions();
```

#### 4.3.3 清理旧分区函数
```sql
CREATE OR REPLACE FUNCTION cleanup_old_log_partitions(retention_years INTEGER DEFAULT 3)
RETURNS TEXT AS $$
DECLARE
    cutoff_date DATE;
    table_record RECORD;
    sql_stmt TEXT;
    result TEXT := '';
BEGIN
    -- 计算保留期限
    cutoff_date := CURRENT_DATE - (retention_years || ' years')::INTERVAL;
    
    -- 查找需要删除的旧分区
    FOR table_record IN 
        SELECT schemaname, tablename 
        FROM pg_tables 
        WHERE tablename LIKE 'operation_logs_y%q%'
        AND tablename < 'operation_logs_y' || EXTRACT(YEAR FROM cutoff_date) || 'q1'
    LOOP
        sql_stmt := 'DROP TABLE IF EXISTS ' || table_record.schemaname || '.' || table_record.tablename;
        EXECUTE sql_stmt;
        result := result || '删除旧分区: ' || table_record.tablename || E'\n';
    END LOOP;
    
    IF result = '' THEN
        result := '没有需要清理的旧分区';
    END IF;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

**使用方法**:
```sql
-- 清理3年前的旧分区
SELECT cleanup_old_log_partitions(3);

-- 清理2年前的旧分区
SELECT cleanup_old_log_partitions(2);
```

## 5. 触发器 (Triggers)

### 5.1 自动更新时间戳触发器

#### 5.1.1 触发器函数
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### 5.1.2 应用的表
```sql
-- 为需要自动更新时间戳的表创建触发器
CREATE TRIGGER trigger_update_products_updated_at 
    BEFORE UPDATE ON products 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_suppliers_updated_at 
    BEFORE UPDATE ON suppliers 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_customers_updated_at 
    BEFORE UPDATE ON customers 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_warehouses_updated_at 
    BEFORE UPDATE ON warehouses 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER trigger_update_batch_traceability_updated_at 
    BEFORE UPDATE ON batch_traceability 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### 5.2 库存流水触发器

#### 5.2.1 触发器函数
```sql
CREATE OR REPLACE FUNCTION update_inventory_from_transaction()
RETURNS TRIGGER AS $$
BEGIN
    -- 更新库存最后修改时间
    UPDATE inventory 
    SET last_updated = CURRENT_TIMESTAMP
    WHERE product_id = NEW.product_id 
      AND warehouse_id = NEW.warehouse_id 
      AND (batch_number = NEW.batch_number OR (batch_number IS NULL AND NEW.batch_number IS NULL));
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### 5.2.2 触发器定义
```sql
CREATE TRIGGER trigger_update_inventory_timestamp
    AFTER INSERT ON inventory_transactions
    FOR EACH ROW EXECUTE FUNCTION update_inventory_from_transaction();
```

## 6. 维护和优化

### 6.1 定期维护任务

#### 6.1.1 物化视图刷新
```sql
-- 每日凌晨刷新库存汇总视图
REFRESH MATERIALIZED VIEW mv_inventory_summary;

-- 检查物化视图大小
SELECT schemaname, matviewname, pg_size_pretty(pg_total_relation_size(schemaname||'.'||matviewname)) as size
FROM pg_matviews;
```

#### 6.1.2 统计信息收集
```sql
-- 收集所有表的统计信息
ANALYZE;

-- 收集特定表的统计信息
ANALYZE inventory;
ANALYZE products;
ANALYZE sales_orders;
```

#### 6.1.3 索引维护
```sql
-- 重建所有索引
REINDEX DATABASE current_database();

-- 重建特定表的索引
REINDEX TABLE inventory;
REINDEX TABLE products;
```

### 6.2 性能监控

#### 6.2.1 视图性能监控
```sql
-- 查看视图执行计划
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM view_inventory_alerts;

-- 查看物化视图大小和刷新时间
SELECT 
    schemaname,
    matviewname,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||matviewname)) as size,
    pg_stat_get_last_analyze_time(c.oid) as last_analyze
FROM pg_matviews m
JOIN pg_class c ON m.matviewname = c.relname;
```

#### 6.2.2 函数性能监控
```sql
-- 查看函数调用统计
SELECT 
    schemaname,
    funcname,
    calls,
    total_time,
    mean_time,
    stddev_time
FROM pg_stat_user_functions
ORDER BY total_time DESC;
```

### 6.3 自动化脚本

#### 6.3.1 日常维护脚本
```bash
#!/bin/bash
# daily_maintenance.sh

# 连接到数据库
psql -U postgres -d bolink_inventory << EOF

-- 刷新物化视图
REFRESH MATERIALIZED VIEW mv_inventory_summary;

-- 自动过期库存预留
SELECT auto_expire_reservations();

-- 收集统计信息
ANALYZE;

-- 检查分区状态
SELECT auto_create_log_partitions();

EOF
```

#### 6.3.2 月度维护脚本
```bash
#!/bin/bash
# monthly_maintenance.sh

# 连接到数据库
psql -U postgres -d bolink_inventory << EOF

-- 重建索引
REINDEX DATABASE current_database();

-- 清理旧分区
SELECT cleanup_old_log_partitions(3);

-- 更新统计信息
ANALYZE VERBOSE;

EOF
```

## 7. 故障排除

### 7.1 常见问题

#### 7.1.1 物化视图刷新失败
**问题**: 物化视图刷新时出现错误
**解决方案**:
```sql
-- 检查物化视图依赖的表
SELECT * FROM pg_depend WHERE objid = 'mv_inventory_summary'::regclass;

-- 手动刷新并查看错误信息
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_inventory_summary;

-- 如果并发刷新失败，使用普通刷新
REFRESH MATERIALIZED VIEW mv_inventory_summary;
```

#### 7.1.2 函数执行缓慢
**问题**: 自定义函数执行时间过长
**解决方案**:
```sql
-- 查看函数执行计划
EXPLAIN (ANALYZE, BUFFERS) SELECT get_available_inventory(1);

-- 检查相关表的索引
SELECT indexname, tablename FROM pg_indexes WHERE tablename IN ('inventory', 'warehouses');

-- 优化函数逻辑或添加索引
```

#### 7.1.3 分区创建失败
**问题**: 自动分区创建失败
**解决方案**:
```sql
-- 检查分区表状态
SELECT schemaname, tablename FROM pg_tables WHERE tablename LIKE 'operation_logs_y%q%';

-- 手动创建分区
SELECT create_quarterly_partition(2025, 1);

-- 检查分区约束
SELECT * FROM pg_partition_tree('operation_logs');
```

### 7.2 性能优化建议

#### 7.2.1 视图优化
- **定期刷新物化视图**: 确保数据及时更新
- **合理使用索引**: 为视图查询添加必要的索引
- **避免复杂计算**: 将复杂计算移到应用层

#### 7.2.2 函数优化
- **减少数据库往返**: 一次查询获取所需数据
- **使用批量操作**: 避免逐行处理
- **合理使用缓存**: 缓存频繁调用的结果

#### 7.2.3 触发器优化
- **避免递归触发**: 防止无限循环
- **减少触发器数量**: 合并相似功能的触发器
- **优化触发器逻辑**: 避免在触发器中执行复杂操作

## 8. 版本管理

### 8.1 版本历史
- **v1.0.0**: 基础版本，包含核心视图和函数
- **v1.0.1**: 增强版本，新增批次追溯、库存预留等功能

### 8.2 升级指南
1. **备份现有数据**: 升级前完整备份
2. **测试环境验证**: 在测试环境验证升级脚本
3. **分步骤升级**: 按模块逐步升级
4. **回滚准备**: 准备回滚脚本

### 8.3 兼容性说明
- **PostgreSQL版本**: 支持PostgreSQL 14及以上版本
- **扩展依赖**: 需要uuid-ossp和pgcrypto扩展
- **权限要求**: 需要创建函数、视图、触发器的权限

---

**文档版本**: 1.0.1  
**最后更新**: 2025-08-24  
**维护人员**: 数据库设计团队
