# 新能源电池进销存系统 - 开发规范

## 项目结构规范

### 前端项目结构 (React + TypeScript)
```
bolink-inventory-frontend/
├── src/
│   ├── components/          # 通用组件
│   │   ├── common/         # 基础组件
│   │   ├── forms/          # 表单组件
│   │   └── charts/         # 图表组件
│   ├── modules/            # 业务模块
│   │   ├── basic-data/     # 基础数据模块
│   │   ├── procurement/    # 采购管理模块
│   │   ├── inventory/      # 库存管理模块
│   │   ├── sales/          # 销售管理模块
│   │   ├── quality/        # 质量控制模块
│   │   ├── safety/         # 安全管理模块
│   │   ├── reports/        # 报表统计模块
│   │   └── system/         # 系统管理模块
│   ├── store/              # Redux状态管理
│   │   ├── slices/         # Redux Toolkit切片
│   │   └── api/            # RTK Query API
│   ├── utils/              # 工具函数
│   ├── types/              # TypeScript类型定义
│   │   ├── api/           # API相关类型
│   │   │   ├── actions/   # Action字典类型
│   │   │   └── responses/ # 响应类型
│   │   └── entities/      # 实体类型
│   ├── hooks/              # 自定义Hook
│   ├── constants/          # 常量定义
│   └── assets/             # 静态资源
├── public/                 # 公共资源
├── tests/                  # 测试文件
└── docs/                   # 文档
```

### 后端项目结构 (NestJS + TypeScript)
```
bolink-inventory-backend/
├── src/
│   ├── modules/            # 业务模块
│   │   ├── basic-data/     # 基础数据模块
│   │   │   ├── entities/   # 实体类
│   │   │   ├── dto/        # 数据传输对象
│   │   │   ├── services/   # 业务服务
│   │   │   └── controllers/ # 控制器
│   │   ├── procurement/    # 采购管理模块
│   │   ├── inventory/      # 库存管理模块
│   │   ├── sales/          # 销售管理模块
│   │   ├── quality/        # 质量控制模块
│   │   ├── safety/         # 安全管理模块
│   │   ├── reports/        # 报表统计模块
│   │   └── system/         # 系统管理模块
│   ├── database/           # 数据库相关
│   │   ├── migrations/     # 数据库迁移
│   │   ├── seeds/          # 种子数据
│   │   ├── views/          # 数据库视图
│   │   └── functions/      # 数据库函数
│   ├── common/             # 通用模块
│   │   ├── decorators/     # 装饰器
│   │   ├── filters/        # 异常过滤器
│   │   ├── guards/         # 守卫
│   │   ├── interceptors/   # 拦截器
│   │   └── pipes/          # 管道
│   ├── database/           # 数据库相关
│   │   ├── migrations/     # 数据库迁移
│   │   └── seeds/          # 种子数据
│   └── config/             # 配置文件
├── test/                   # 测试文件
└── docs/                   # 文档
```

## 命名规范

### 文件和目录命名
- **目录**: 使用kebab-case，如 `basic-data`, `inventory-management`
- **组件文件**: PascalCase，如 `ProductList.tsx`, `InventoryTable.tsx`
- **工具文件**: camelCase，如 `formatCurrency.ts`, `validateEmail.ts`
- **常量文件**: UPPER_SNAKE_CASE，如 `API_ENDPOINTS.ts`, `ERROR_CODES.ts`

### 变量和函数命名
```typescript
// 变量使用camelCase
const userName = 'admin';
const productList = [];
const isAuthenticated = true;

// 函数使用camelCase
function getUserInfo() {}
function calculateTotalPrice() {}
async function fetchProductData() {}

// 常量使用UPPER_SNAKE_CASE
const MAX_RETRY_COUNT = 3;
const API_BASE_URL = 'https://api.example.com';
const DEFAULT_PAGE_SIZE = 20;

// 接口使用PascalCase，加I前缀
interface IUser {
  id: number;
  username: string;
}

// 类型使用PascalCase
type ProductStatus = 'active' | 'inactive' | 'discontinued';

// 枚举使用PascalCase
enum OrderStatus {
  Draft = 'draft',
  Pending = 'pending',
  Approved = 'approved',
  Cancelled = 'cancelled'
}
```

### 数据库命名
```sql
-- 表名使用snake_case复数形式
products, suppliers, customers, purchase_orders

-- 字段名使用snake_case
product_code, created_at, updated_at, supplier_id

-- 索引名使用idx_前缀
idx_products_code, idx_suppliers_type

-- 外键约束使用fk_前缀
fk_purchase_orders_supplier_id
```

## 代码风格规范

### TypeScript/JavaScript规范
```typescript
// 使用const和let，避免使用var
const apiUrl = 'https://api.example.com';
let currentUser = null;

// 使用箭头函数
const handleClick = (event: MouseEvent) => {
  console.log('Button clicked');
};

// 使用模板字符串
const message = `Welcome, ${userName}!`;

// 使用解构赋值
const { productCode, productName, price } = product;

// 使用扩展运算符
const newProduct = { ...existingProduct, status: 'active' };

// 类型注解
function calculateDiscount(price: number, discountRate: number): number {
  return price * (1 - discountRate);
}

// 可选链操作符
const address = user?.profile?.address?.street;

// 空值合并操作符
const defaultTheme = userPreference?.theme ?? 'light';
```

### React组件规范
```typescript
// 函数组件使用箭头函数
const ProductCard: React.FC<ProductCardProps> = ({ product, onEdit }) => {
  // 使用useState Hook
  const [isLoading, setIsLoading] = useState(false);
  
  // 使用useEffect Hook
  useEffect(() => {
    // 副作用逻辑
  }, [product.id]);
  
  // 事件处理函数
  const handleEdit = useCallback(() => {
    onEdit(product.id);
  }, [product.id, onEdit]);
  
  // 条件渲染
  if (isLoading) {
    return <CircularProgress />;
  }
  
  return (
    <Card>
      <CardContent>
        <Typography variant="h6">{product.name}</Typography>
        <Typography variant="body2">{product.description}</Typography>
        <Button onClick={handleEdit}>编辑</Button>
      </CardContent>
    </Card>
  );
};

// Props接口定义
interface ProductCardProps {
  product: Product;
  onEdit: (productId: number) => void;
}
```

### NestJS服务规范
```typescript
@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
    private readonly logger: Logger,
  ) {}

  async findAll(query: FindProductsDto): Promise<PaginatedResult<Product>> {
    try {
      const { page = 1, pageSize = 20, search, status } = query;
      
      const queryBuilder = this.productRepository.createQueryBuilder('product');
      
      if (search) {
        queryBuilder.where('product.name ILIKE :search', { 
          search: `%${search}%` 
        });
      }
      
      if (status) {
        queryBuilder.andWhere('product.status = :status', { status });
      }
      
      const [products, total] = await queryBuilder
        .skip((page - 1) * pageSize)
        .take(pageSize)
        .getManyAndCount();
      
      return {
        data: products,
        total,
        page,
        pageSize,
      };
    } catch (error) {
      this.logger.error('Failed to fetch products', error);
      throw new InternalServerErrorException('Failed to fetch products');
    }
  }

  async create(createProductDto: CreateProductDto): Promise<Product> {
    const product = this.productRepository.create(createProductDto);
    return this.productRepository.save(product);
  }
}
```

## Git工作流规范

### 分支命名规范
- **主分支**: `main`
- **开发分支**: `develop`
- **功能分支**: `feature/模块名-功能描述`
- **修复分支**: `bugfix/问题描述`
- **发布分支**: `release/版本号`
- **热修复分支**: `hotfix/问题描述`

示例:
```bash
feature/inventory-stock-management
feature/procurement-order-approval
bugfix/inventory-negative-quantity
release/v1.2.0
hotfix/critical-security-fix
```

### 提交信息规范
使用Conventional Commits规范:
```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

类型说明:
- **feat**: 新功能
- **fix**: 修复bug
- **docs**: 文档更新
- **style**: 代码格式化
- **refactor**: 重构代码
- **test**: 测试相关
- **chore**: 构建工具或辅助工具变动

示例:
```bash
feat(inventory): add real-time stock monitoring
fix(procurement): resolve order approval workflow issue
docs(api): update authentication documentation
refactor(sales): extract order validation logic
test(quality): add unit tests for inspection service
```

### 代码提交流程
```bash
# 1. 创建功能分支
git checkout -b feature/inventory-alerts

# 2. 开发和提交
git add .
git commit -m "feat(inventory): implement stock alert system"

# 3. 推送分支
git push origin feature/inventory-alerts

# 4. 创建Pull Request
# 通过GitHub/GitLab界面创建PR

# 5. 代码审查后合并
git checkout develop
git pull origin develop
git merge feature/inventory-alerts
git push origin develop

# 6. 删除功能分支
git branch -d feature/inventory-alerts
git push origin --delete feature/inventory-alerts
```

## 测试规范

### 前端测试
```typescript
// 组件测试 - ProductCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { ProductCard } from './ProductCard';

describe('ProductCard', () => {
  const mockProduct = {
    id: 1,
    code: 'BT-001',
    name: '锂电池',
    price: 100,
  };

  const mockOnEdit = jest.fn();

  beforeEach(() => {
    mockOnEdit.mockClear();
  });

  it('should render product information', () => {
    render(<ProductCard product={mockProduct} onEdit={mockOnEdit} />);
    
    expect(screen.getByText('锂电池')).toBeInTheDocument();
    expect(screen.getByText('BT-001')).toBeInTheDocument();
  });

  it('should call onEdit when edit button is clicked', () => {
    render(<ProductCard product={mockProduct} onEdit={mockOnEdit} />);
    
    fireEvent.click(screen.getByText('编辑'));
    
    expect(mockOnEdit).toHaveBeenCalledWith(1);
  });
});
```

### 后端测试
```typescript
// 服务测试 - product.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ProductService } from './product.service';
import { Product } from './entities/product.entity';

describe('ProductService', () => {
  let service: ProductService;
  let repository: Repository<Product>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ProductService,
        {
          provide: getRepositoryToken(Product),
          useValue: {
            find: jest.fn(),
            findOne: jest.fn(),
            create: jest.fn(),
            save: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<ProductService>(ProductService);
    repository = module.get<Repository<Product>>(getRepositoryToken(Product));
  });

  it('should create a product', async () => {
    const createProductDto = {
      code: 'BT-001',
      name: '锂电池',
      price: 100,
    };

    const savedProduct = { id: 1, ...createProductDto };

    jest.spyOn(repository, 'create').mockReturnValue(savedProduct as Product);
    jest.spyOn(repository, 'save').mockResolvedValue(savedProduct as Product);

    const result = await service.create(createProductDto);

    expect(repository.create).toHaveBeenCalledWith(createProductDto);
    expect(repository.save).toHaveBeenCalledWith(savedProduct);
    expect(result).toEqual(savedProduct);
  });
});
```

## 性能优化规范

### 前端性能优化
```typescript
// 1. 使用React.memo优化组件
const ProductCard = React.memo<ProductCardProps>(({ product, onEdit }) => {
  // 组件实现
});

// 2. 使用useMemo优化计算
const expensiveValue = useMemo(() => {
  return complexCalculation(data);
}, [data]);

// 3. 使用useCallback优化函数
const handleClick = useCallback((id: number) => {
  onEdit(id);
}, [onEdit]);

// 4. 代码分割
const LazyComponent = React.lazy(() => import('./ExpensiveComponent'));

// 5. 虚拟化长列表
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items }) => (
  <List
    height={600}
    itemCount={items.length}
    itemSize={50}
    itemData={items}
  >
    {({ index, style, data }) => (
      <div style={style}>
        {data[index].name}
      </div>
    )}
  </List>
);
```

### 后端性能优化
```typescript
// 1. 数据库查询优化
@Entity()
export class Product {
  @Index()
  @Column()
  code: string;

  @Index()
  @Column()
  status: string;
}

// 2. 缓存优化
@Injectable()
export class ProductService {
  @Cacheable('products', 300) // 缓存5分钟
  async findById(id: number): Promise<Product> {
    return this.productRepository.findOne({ where: { id } });
  }
}

// 3. 分页查询
async findAll(query: FindProductsDto): Promise<PaginatedResult<Product>> {
  const [data, total] = await this.productRepository.findAndCount({
    skip: (query.page - 1) * query.pageSize,
    take: query.pageSize,
  });
  
  return { data, total, page: query.page, pageSize: query.pageSize };
}

// 4. 批量操作
async batchCreate(products: CreateProductDto[]): Promise<Product[]> {
  return this.productRepository.save(
    this.productRepository.create(products)
  );
}
```

## 错误处理规范

### 前端错误处理
```typescript
// 1. 错误边界组件
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <ErrorFallback />;
    }

    return this.props.children;
  }
}

// 2. API错误处理
const apiSlice = createApi({
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/v1',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  endpoints: (builder) => ({
    getProducts: builder.query({
      query: () => 'products',
      transformErrorResponse: (response) => ({
        status: response.status,
        message: response.data?.message || 'Unknown error',
      }),
    }),
  }),
});
```

### 后端错误处理
```typescript
// 1. 全局异常过滤器
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      message = exception.message;
    }

    response.status(status).json({
      success: false,
      code: status,
      message,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}

// 2. 业务异常类
export class InsufficientStockException extends HttpException {
  constructor(productId: number, requested: number, available: number) {
    super(
      `Insufficient stock for product ${productId}. Requested: ${requested}, Available: ${available}`,
      HttpStatus.BAD_REQUEST,
    );
  }
}
```

## 统一API设计规范

### Action字典定义规范

#### 1. TypeScript类型定义
```typescript
// src/types/api/actions/product.actions.ts
export type ProductAction =
  // 基础CRUD操作
  | 'create'    // 创建产品
  | 'list'      // 查询产品列表
  | 'detail'    // 获取产品详情
  | 'update'    // 更新产品
  | 'delete'    // 删除产品

  // 批量操作
  | 'batch-import'  // 批量导入
  | 'batch-export'  // 批量导出
  | 'batch-delete'  // 批量删除

  // 验证操作
  | 'validate-code' // 产品编码验证
  | 'validate-model' // 型号重复验证

  // 状态管理
  | 'enable'    // 启用产品
  | 'disable'   // 停用产品
  | 'discontinue' // 淘汰产品

  // 技术参数管理
  | 'specs'     // 技术参数查询
  | 'update-specs' // 更新技术参数

  // 认证管理
  | 'certifications' // 认证信息管理
  | 'add-certification' // 添加认证
  | 'remove-certification' // 移除认证

  // 统计报表
  | 'statistics' // 产品统计
  | 'report';    // 生成报表

// 请求参数类型
export interface ProductRequest {
  action: ProductAction;
  data?: any;
  params?: any;
}

// 响应类型
export interface ProductResponse<T = any> {
  success: boolean;
  data: T;
  message?: string;
  total?: number;
  page?: number;
  pageSize?: number;
}
```

#### 2. 模块专属Action字典规范
```typescript
// 采购计划Action字典
export type ProcurementPlanAction =
  | 'create' | 'list' | 'detail' | 'update' | 'delete'
  | 'draft' | 'submit' | 'approve' | 'reject' | 'cancel'
  | 'batch-approve' | 'batch-reject'
  | 'statistics' | 'export';

// 库存管理Action字典
export type InventoryStockAction =
  | 'list' | 'detail' | 'movement' | 'aging' | 'abc'
  | 'reserve' | 'unreserve' | 'adjust'
  | 'batch-adjust' | 'batch-reserve'
  | 'statistics' | 'export';

// 销售订单Action字典
export type SalesOrderAction =
  | 'create' | 'list' | 'detail' | 'update' | 'delete'
  | 'draft' | 'submit' | 'confirm' | 'ship' | 'complete'
  | 'cancel' | 'refund'
  | 'batch-confirm' | 'batch-ship'
  | 'statistics' | 'export';
```

### 后端接口实现规范

#### 1. 控制器实现
```typescript
// src/modules/basic-data/controllers/product.controller.ts
@Controller('api/basic-data/products')
export class ProductController {
  constructor(private readonly productService: ProductService) {}

  @Post()
  @ApiOperation({ summary: '产品管理统一接口' })
  @ApiBody({ 
    description: '产品操作请求',
    type: ProductRequestDto 
  })
  @ApiResponse({ 
    status: 200, 
    description: '操作成功',
    type: ProductResponseDto 
  })
  async handleAction(@Body() request: ProductRequestDto) {
    const { action, data, params } = request;
    
    try {
      switch (action) {
        case 'create':
          return await this.productService.create(data);
        
        case 'list':
          return await this.productService.findAll(params);
        
        case 'detail':
          return await this.productService.findById(params.id);
        
        case 'update':
          return await this.productService.update(params.id, data);
        
        case 'delete':
          return await this.productService.delete(params.id);
        
        case 'validate-code':
          return await this.productService.validateCode(data.code);
        
        case 'enable':
          return await this.productService.updateStatus(params.id, 'active');
        
        case 'disable':
          return await this.productService.updateStatus(params.id, 'inactive');
        
        case 'batch-import':
          return await this.productService.batchImport(data.products);
        
        case 'batch-export':
          return await this.productService.batchExport(params);
        
        case 'statistics':
          return await this.productService.getStatistics(params);
        
        default:
          throw new BadRequestException(`Unsupported action: ${action}`);
      }
    } catch (error) {
      this.logger.error(`Product action failed: ${action}`, error);
      throw error;
    }
  }
}
```

#### 2. 服务层实现
```typescript
// src/modules/basic-data/services/product.service.ts
@Injectable()
export class ProductService {
  constructor(
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
    private readonly logger: Logger,
  ) {}

  async create(createProductDto: CreateProductDto): Promise<Product> {
    // 验证产品编码唯一性
    await this.validateCode(createProductDto.code);
    
    const product = this.productRepository.create(createProductDto);
    return this.productRepository.save(product);
  }

  async findAll(query: FindProductsDto): Promise<PaginatedResult<Product>> {
    const { page = 1, pageSize = 20, search, status, batteryType } = query;
    
    const queryBuilder = this.productRepository.createQueryBuilder('product');
    
    if (search) {
      queryBuilder.where(
        'product.name ILIKE :search OR product.code ILIKE :search',
        { search: `%${search}%` }
      );
    }
    
    if (status) {
      queryBuilder.andWhere('product.status = :status', { status });
    }
    
    if (batteryType) {
      queryBuilder.andWhere('product.batteryType = :batteryType', { batteryType });
    }
    
    const [data, total] = await queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize)
      .orderBy('product.createdAt', 'DESC')
      .getManyAndCount();
    
    return { data, total, page, pageSize };
  }

  async validateCode(code: string): Promise<{ isValid: boolean; message?: string }> {
    const existingProduct = await this.productRepository.findOne({
      where: { code }
    });
    
    if (existingProduct) {
      return { isValid: false, message: '产品编码已存在' };
    }
    
    return { isValid: true };
  }

  async updateStatus(id: number, status: ProductStatus): Promise<Product> {
    const product = await this.productRepository.findOne({ where: { id } });
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    
    product.status = status;
    return this.productRepository.save(product);
  }

  async batchImport(products: CreateProductDto[]): Promise<{ success: number; failed: number }> {
    let success = 0;
    let failed = 0;
    
    for (const productData of products) {
      try {
        await this.create(productData);
        success++;
      } catch (error) {
        this.logger.error(`Failed to import product: ${productData.code}`, error);
        failed++;
      }
    }
    
    return { success, failed };
  }

  async getStatistics(params: any): Promise<ProductStatistics> {
    // 实现统计逻辑
    const totalProducts = await this.productRepository.count();
    const activeProducts = await this.productRepository.count({
      where: { status: 'active' }
    });
    
    return {
      total: totalProducts,
      active: activeProducts,
      inactive: totalProducts - activeProducts,
    };
  }
}
```

### 前端调用规范

#### 1. RTK Query API定义
```typescript
// src/store/api/productApi.ts
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { ProductAction, ProductRequest, ProductResponse } from '@/types/api/actions/product.actions';

export const productApi = createApi({
  reducerPath: 'productApi',
  baseQuery: fetchBaseQuery({
    baseUrl: '/api/basic-data/products',
    prepareHeaders: (headers, { getState }) => {
      const token = getState().auth.token;
      if (token) {
        headers.set('authorization', `Bearer ${token}`);
      }
      return headers;
    },
  }),
  tagTypes: ['Product'],
  endpoints: (builder) => ({
    // 统一产品接口
    productAction: builder.mutation<ProductResponse, ProductRequest>({
      query: (request) => ({
        url: '',
        method: 'POST',
        body: request,
      }),
      invalidatesTags: (result, error, { action }) => {
        // 根据action类型决定缓存失效策略
        switch (action) {
          case 'create':
          case 'update':
          case 'delete':
            return [{ type: 'Product', id: 'LIST' }];
          case 'enable':
          case 'disable':
            return [{ type: 'Product', id: 'LIST' }];
          default:
            return [];
        }
      },
    }),
  }),
});

export const { useProductActionMutation } = productApi;
```

#### 2. 组件调用示例
```typescript
// src/modules/basic-data/components/ProductList.tsx
import React, { useState, useEffect } from 'react';
import { useProductActionMutation } from '@/store/api/productApi';
import { ProductAction } from '@/types/api/actions/product.actions';

const ProductList: React.FC = () => {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(false);
  const [productAction] = useProductActionMutation();

  // 获取产品列表
  const fetchProducts = async (params = {}) => {
    setLoading(true);
    try {
      const response = await productAction({
        action: 'list',
        params: { page: 1, pageSize: 20, ...params }
      });
      
      if (response.data.success) {
        setProducts(response.data.data);
      }
    } catch (error) {
      console.error('Failed to fetch products:', error);
    } finally {
      setLoading(false);
    }
  };

  // 创建产品
  const handleCreate = async (productData: any) => {
    try {
      const response = await productAction({
        action: 'create',
        data: productData
      });
      
      if (response.data.success) {
        // 刷新列表
        fetchProducts();
        // 显示成功消息
        message.success('产品创建成功');
      }
    } catch (error) {
      console.error('Failed to create product:', error);
      message.error('产品创建失败');
    }
  };

  // 验证产品编码
  const validateCode = async (code: string): Promise<boolean> => {
    try {
      const response = await productAction({
        action: 'validate-code',
        data: { code }
      });
      
      return response.data.data.isValid;
    } catch (error) {
      return false;
    }
  };

  // 启用/禁用产品
  const handleStatusChange = async (id: number, action: 'enable' | 'disable') => {
    try {
      const response = await productAction({
        action,
        params: { id }
      });
      
      if (response.data.success) {
        fetchProducts();
        message.success(`产品${action === 'enable' ? '启用' : '禁用'}成功`);
      }
    } catch (error) {
      message.error(`产品${action === 'enable' ? '启用' : '禁用'}失败`);
    }
  };

  useEffect(() => {
    fetchProducts();
  }, []);

  return (
    <div>
      {/* 组件渲染逻辑 */}
    </div>
  );
};

export default ProductList;
```

#### 3. 自定义Hook封装
```typescript
// src/modules/basic-data/hooks/useProductActions.ts
import { useProductActionMutation } from '@/store/api/productApi';
import { ProductAction } from '@/types/api/actions/product.actions';
import { message } from 'antd';

export const useProductActions = () => {
  const [productAction] = useProductActionMutation();

  const executeAction = async (
    action: ProductAction,
    data?: any,
    params?: any,
    successMessage?: string
  ) => {
    try {
      const response = await productAction({ action, data, params });
      
      if (response.data.success) {
        if (successMessage) {
          message.success(successMessage);
        }
        return response.data;
      } else {
        message.error(response.data.message || '操作失败');
        return null;
      }
    } catch (error) {
      console.error(`Product action failed: ${action}`, error);
      message.error('操作失败，请稍后重试');
      return null;
    }
  };

  return {
    executeAction,
    // 便捷方法
    create: (data: any) => executeAction('create', data, undefined, '产品创建成功'),
    update: (id: number, data: any) => executeAction('update', data, { id }, '产品更新成功'),
    delete: (id: number) => executeAction('delete', undefined, { id }, '产品删除成功'),
    enable: (id: number) => executeAction('enable', undefined, { id }, '产品启用成功'),
    disable: (id: number) => executeAction('disable', undefined, { id }, '产品禁用成功'),
    validateCode: (code: string) => executeAction('validate-code', { code }),
  };
};
```

### 注释规范

#### 1. Action字典注释规范
```typescript
/**
 * 产品管理操作类型字典
 * 
 * 本字典定义了产品模块支持的所有操作类型，包括：
 * - 基础CRUD操作：创建、查询、更新、删除
 * - 批量操作：批量导入、导出、删除
 * - 验证操作：编码验证、型号验证
 * - 状态管理：启用、禁用、淘汰
 * - 业务操作：技术参数管理、认证管理
 * - 统计报表：数据统计、报表生成
 * 
 * 每个action都有明确的业务含义和对应的后端处理逻辑
 */
export type ProductAction =
  // 基础CRUD操作
  | 'create'    // 创建产品 - 新增产品信息到系统
  | 'list'      // 查询产品列表 - 支持分页、搜索、筛选
  | 'detail'    // 获取产品详情 - 获取单个产品的完整信息
  | 'update'    // 更新产品 - 修改产品基本信息
  | 'delete'    // 删除产品 - 逻辑删除，标记为已删除状态

  // 批量操作
  | 'batch-import'  // 批量导入 - 从Excel文件批量导入产品
  | 'batch-export'  // 批量导出 - 导出产品数据到Excel文件
  | 'batch-delete'  // 批量删除 - 批量删除选中的产品

  // 验证操作
  | 'validate-code' // 产品编码验证 - 检查编码唯一性
  | 'validate-model' // 型号重复验证 - 检查型号是否重复

  // 状态管理
  | 'enable'    // 启用产品 - 将产品状态改为启用
  | 'disable'   // 停用产品 - 将产品状态改为停用
  | 'discontinue' // 淘汰产品 - 标记产品为已淘汰

  // 技术参数管理
  | 'specs'     // 技术参数查询 - 获取产品的技术规格参数
  | 'update-specs' // 更新技术参数 - 修改产品的技术规格

  // 认证管理
  | 'certifications' // 认证信息管理 - 获取产品的认证信息列表
  | 'add-certification' // 添加认证 - 为产品添加新的认证信息
  | 'remove-certification' // 移除认证 - 删除产品的认证信息

  // 统计报表
  | 'statistics' // 产品统计 - 获取产品的统计数据
  | 'report';    // 生成报表 - 生成产品相关的分析报表
```

#### 2. 接口实现注释规范
```typescript
/**
 * 产品管理统一接口
 * 
 * 处理所有产品相关的操作请求，通过action参数区分具体的操作类型。
 * 支持的产品操作包括：CRUD、批量操作、验证、状态管理、统计等。
 * 
 * @param request - 包含action、data、params的请求对象
 * @returns 根据action类型返回相应的响应数据
 * 
 * @example
 * ```typescript
 * // 创建产品
 * const response = await productAction({
 *   action: 'create',
 *   data: { name: '锂电池', code: 'BT-001' }
 * });
 * 
 * // 查询产品列表
 * const response = await productAction({
 *   action: 'list',
 *   params: { page: 1, pageSize: 20, status: 'active' }
 * });
 * 
 * // 验证产品编码
 * const response = await productAction({
 *   action: 'validate-code',
 *   data: { code: 'BT-001' }
 * });
 * ```
 */
async handleAction(@Body() request: ProductRequestDto) {
  const { action, data, params } = request;
  
  // 记录操作日志
  this.logger.log(`Processing product action: ${action}`, { data, params });
  
  try {
    switch (action) {
      case 'create':
        // 创建产品：验证数据 -> 检查重复 -> 保存到数据库
        return await this.productService.create(data);
      
      case 'list':
        // 查询列表：构建查询条件 -> 执行分页查询 -> 返回结果
        return await this.productService.findAll(params);
      
      case 'detail':
        // 获取详情：根据ID查询 -> 返回完整产品信息
        return await this.productService.findById(params.id);
      
      case 'update':
        // 更新产品：验证数据 -> 更新数据库 -> 返回更新后的产品
        return await this.productService.update(params.id, data);
      
      case 'delete':
        // 删除产品：逻辑删除 -> 更新状态为已删除
        return await this.productService.delete(params.id);
      
      case 'validate-code':
        // 验证编码：检查数据库中是否存在相同编码
        return await this.productService.validateCode(data.code);
      
      case 'enable':
        // 启用产品：更新状态为启用
        return await this.productService.updateStatus(params.id, 'active');
      
      case 'disable':
        // 禁用产品：更新状态为禁用
        return await this.productService.updateStatus(params.id, 'inactive');
      
      case 'batch-import':
        // 批量导入：解析Excel -> 验证数据 -> 批量保存
        return await this.productService.batchImport(data.products);
      
      case 'batch-export':
        // 批量导出：查询数据 -> 生成Excel文件 -> 返回下载链接
        return await this.productService.batchExport(params);
      
      case 'statistics':
        // 统计数据：计算各种统计指标
        return await this.productService.getStatistics(params);
      
      default:
        // 不支持的操作类型
        throw new BadRequestException(`Unsupported action: ${action}`);
    }
  } catch (error) {
    // 记录错误日志
    this.logger.error(`Product action failed: ${action}`, error);
    throw error;
  }
}
```
